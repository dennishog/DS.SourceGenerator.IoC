using DS.SourceGenerator.IoC.Attributes.Enums;
using DS.SourceGenerator.IoC.Extensions;
using DS.SourceGenerator.IoC.Generators.SyntaxRecievers;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Text;
using System.Linq;
using System.Text;

namespace DS.SourceGenerator.IoC.Generators
{
    [Generator]
    public class InjectionGenerator : ISourceGenerator
    {
        public void Execute(GeneratorExecutionContext context)
        {
            var receiver = (ClassDeclarationReciever?)context.SyntaxReceiver;
            if (receiver == null || !receiver.InjectAttributeClasses.Any())
                return;

            var registrations = new StringBuilder();

            foreach (var @class in receiver.InjectAttributeClasses)
            {
                //Debugger.Launch();
                var semanticModel = context.Compilation.GetSemanticModel(@class.SyntaxTree);
                if (semanticModel == null)
                    continue;
                var symbol = semanticModel.GetDeclaredSymbol(@class);
                if (symbol == null)
                    continue;

                var injectAttribute = symbol.GetInjectAttribute();
                if (injectAttribute == null)
                    continue;

                var constructorAttributes = symbol.GetInjectConfigurationParameterAttributes();
                if (constructorAttributes != null)
                {
                    var constructorParameters = symbol.GetConstructorParameters();

                    if (constructorParameters == null)
                        continue;

                    switch (injectAttribute.Value.injectionMethod)
                    {
                        case InjectionMethods.Scoped:
                            registrations.Append($"            self.AddScoped<{injectAttribute.Value.interfaceFullName}>(x => new {symbol.GetFullName()}(");
                            break;
                        case InjectionMethods.Singleton:
                            registrations.Append($"            self.AddSingleton<{injectAttribute.Value.interfaceFullName}>(x => new {symbol.GetFullName()}(");
                            break;
                        default:
                            registrations.Append($"            self.AddTransient<{injectAttribute.Value.interfaceFullName}>(x => new {symbol.GetFullName()}(");
                            break;
                    }



                    for (var i = 0; i < constructorParameters.Count; i++)
                    {
                        var parameter = constructorParameters.ElementAt(i);

                        registrations.Append(constructorAttributes.Any(x => x.Parameter == parameter.Key)
                            ? $"configuration.GetValue<string>(\"{constructorAttributes.Single(x => x.Parameter == parameter.Key).ConfigurationPath}\")"
                            : $"x.GetService<{parameter.Value}>()");

                        if (i < constructorParameters.Count - 1)
                            registrations.Append(", ");
                    }

                    registrations.AppendLine("));");
                }
                else
                {
                    switch (injectAttribute.Value.injectionMethod)
                    {
                        case InjectionMethods.Scoped:
                            registrations.AppendLine($"            self.AddScoped<{injectAttribute.Value.interfaceFullName}, {symbol.GetFullName()}>();");
                            break;
                        case InjectionMethods.Singleton:
                            registrations.AppendLine($"            self.AddSingleton<{injectAttribute.Value.interfaceFullName}, {symbol.GetFullName()}>();");
                            break;
                        default:
                            registrations.AppendLine($"            self.AddTransient<{injectAttribute.Value.interfaceFullName}, {symbol.GetFullName()}>();");
                            break;
                    }
                }
            }

            context.AddSource("ServiceCollectionExtensions.cs", SourceText.From(GenerateExtensionClass(registrations.ToString()), Encoding.UTF8));
        }

        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(() => new ClassDeclarationReciever());
        }

        private string GenerateExtensionClass(string registrations)
        {
            return $@"
//--------------------------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>
//--------------------------------------------------------------------------------------------------
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Configuration;

namespace DS.SourceGenerators.Extensions {{
    public static class ServiceCollectionExtensions {{
        public static IServiceCollection AddIoCRegistrations(this IServiceCollection self, IConfiguration configuration) {{
{registrations}
            return self;
        }}
    }}
}}
";
        }
    }
}
